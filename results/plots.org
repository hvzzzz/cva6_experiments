#+title: Plots
#+OPTIONS: tags:t
#+EXPORT_EXCLUDE_TAGS: noexport
* Benchmarks
** Individual benchmarks

#+begin_src jupyter-python :results output drawer :exports results
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import os
import re
import warnings

# --- 1. Global Setup ---
RESULTS_DIR = "/home/han4n/cva6_experiments/results"
PLOTS_DIR = os.path.join(RESULTS_DIR, "individual_benchmark_profiles")
os.makedirs(PLOTS_DIR, exist_ok=True)

# LaTeX & Style Settings
plt.rc('text', usetex=True)
plt.rc('font', family='serif')
plt.rcParams['figure.dpi'] = 300
warnings.filterwarnings("ignore")

# --- 2. Helper Functions ---
def prettify_config(conf):
    """Translates internal config names to descriptive publication labels."""
    if conf == "Ref": return "Baseline"

    # Cache: "IC/DC 16k" -> "16KB L1 Cache"
    m = re.search(r'IC/DC (\d+)k', str(conf), re.IGNORECASE)
    if m: return f"{m.group(1)}KB L1 Cache"

    # Associativity: "2w" -> "2-Way Assoc"
    m = re.search(r'^(\d+)w$', str(conf), re.IGNORECASE)
    if m: return f"{m.group(1)}-Way Assoc"

    # BTB: "BTB32" -> "32-Entry BTB"
    m = re.search(r'BTB(\d+)', str(conf), re.IGNORECASE)
    if m: return f"{m.group(1)}-Entry BTB"

    # BHT: "BHT32" -> "32-Entry BHT"
    m = re.search(r'BHT(\d+)', str(conf), re.IGNORECASE)
    if m: return f"{m.group(1)}-Entry BHT"

    return conf

def get_sort_value(config_str):
    m = re.search(r'(\d+)', str(config_str))
    if m: return int(m.group(1))
    return 0

def format_y_label(unit_str):
    """Converts raw unit strings into descriptive 'Quantity [Unit]' format."""
    unit_str = str(unit_str).strip()

    if unit_str == 'lps':
        return r"Throughput [Loops/s]"
    elif unit_str == 'Mop/s':
        return r"Throughput [Mop/s]"
    elif unit_str == 'KBps':
        return r"Data Rate [KB/s]"
    elif unit_str == 'MWIPS':
        return r"Processing Speed [MWIPS]"
    else:
        # Fallback for unknown units
        return fr"{Score [{unit_str}]}"

# --- 3. Data Loading & Merging ---
sources = [
    {"name": "Baseline",      "file": "baseline_results.csv",                  "color": "gray"},
    {"name": "Cache Size",    "file": "cache_sweep_benchmark_results.csv",     "color": "dodgerblue"},
    {"name": "Associativity", "file": "associativity_sweep_benchmark_results.csv", "color": "forestgreen"},
    {"name": "BTB Size",      "file": "btb_sweep_benchmark_results.csv",       "color": "darkorange"},
    {"name": "BHT Size",      "file": "bht_sweep_benchmark_results.csv",       "color": "purple"},
]

df_master = pd.DataFrame()
for src in sources:
    file_path = os.path.join(RESULTS_DIR, src["file"])
    if os.path.exists(file_path):
        temp_df = pd.read_csv(file_path)
        temp_df['sweep_type'] = src["name"]
        if src["name"] == "Baseline":
            temp_df['config'] = "Ref"
        df_master = pd.concat([df_master, temp_df], ignore_index=True)

# Identify all benchmarks
benchmarks = df_master['name'].unique()
palette = {src["name"]: src["color"] for src in sources}

print(f"Generating publication-ready images for {len(benchmarks)} benchmarks...")

# --- 4. Main Generation Loop ---
for bench in benchmarks:
    subset = df_master[df_master['name'] == bench].copy()
    if subset.empty: continue

    # A. Sorting Logic
    subset['sweep_type'] = pd.Categorical(
        subset['sweep_type'],
        categories=["Baseline", "Cache Size", "Associativity", "BTB Size", "BHT Size"],
        ordered=True
    )
    subset['sort_val'] = subset.apply(
        lambda row: -1 if row['sweep_type'] == 'Baseline' else get_sort_value(row['config']),
        axis=1
    )
    subset = subset.sort_values(by=['sweep_type', 'sort_val'])

    # B. Apply Descriptive Labels
    subset['pretty_config'] = subset['config'].apply(prettify_config)

    # C. Dynamic Zoom Calculation
    min_score = subset['score'].min()
    max_score = subset['score'].max()
    diff = max_score - min_score
    if diff == 0: diff = max_score * 0.01
    y_min = max(0, min_score - (diff * 0.5))
    y_max = max_score + (diff * 0.5)

    # D. Plotting
    fig, ax1 = plt.subplots(figsize=(11, 7))
    sns.set_theme(style="whitegrid")

    # Bar Chart (Score)
    sns.barplot(
        data=subset, x="pretty_config", y="score", hue="sweep_type",
        palette=palette, dodge=False, ax=ax1, alpha=0.85
    )
    ax1.set_ylim(y_min, y_max)

    # --- UPDATED Y-AXIS LABEL ---
    raw_unit = subset['units'].iloc[0]
    descriptive_label = format_y_label(raw_unit)
    ax1.set_ylabel(descriptive_label, fontsize=12)

    ax1.set_xlabel("")
    ax1.tick_params(axis='x', rotation=70, labelsize=10)

    # Line Chart (IPC)
    ax2 = ax1.twinx()
    sns.pointplot(
        data=subset, x="pretty_config", y="ipc", color="red",
        markers="o", scale=0.7, ax=ax2, linestyles="-"
    )

    # --- UPDATED SECONDARY Y-AXIS LABEL ---
    ax2.set_ylabel(r"Efficiency [IPC]", color="red", fontsize=12)
    ax2.tick_params(axis='y', labelcolor="red")

    # Baseline Reference Line
    base_rows = subset[subset['sweep_type'] == "Baseline"]
    if not base_rows.empty:
        base_val = base_rows['score'].values[0]
        baseline_text = (
            "Baseline Config:\n"
            r"$\bullet$ 4KB L1 Cache" "\n"
            r"$\bullet$ 4-Way Assoc" "\n"
            r"$\bullet$ 16-Entry BTB" "\n"
            r"$\bullet$ 16-Entry BHT"
        )
        ax1.axhline(base_val, color='black', linestyle='--', linewidth=1.5, alpha=0.6, label=baseline_text)

    # --- UPDATED DESCRIPTIVE TITLE ---
    # Using 'Sensitivity Analysis' describes the plot's purpose better than just 'Profile'
    plt.title(f"Microarchitectural Sensitivity Analysis: {bench}", fontsize=16, pad=15)

    # Legend Construction
    handles, labels = ax1.get_legend_handles_labels()
    unique_labels = []
    unique_handles = []
    seen = set()
    base_h, base_l = None, None

    for h, l in zip(handles, labels):
        if "Baseline Config" in l:
            base_h, base_l = h, l
        elif l not in seen:
            seen.add(l)
            unique_labels.append(l)
            unique_handles.append(h)

    if base_h:
        unique_handles.append(base_h)
        unique_labels.append(base_l)

    ax1.legend(
        unique_handles, unique_labels,
        title="Parameters", bbox_to_anchor=(1.12, 1), loc='upper left'
    )

    # E. Explanatory Text Below X-Axis
    plt.figtext(
        0.5, 0.02,
        "Hardware Configuration.",
        ha="center", fontsize=10, style='italic'
    )

    # F. Save
    plt.tight_layout()
    plt.subplots_adjust(bottom=0.2)

    save_path = os.path.join(PLOTS_DIR, f"benchmark_{bench}.png")
    plt.savefig(save_path, bbox_inches='tight')
    plt.close()

print(f"Success! All images saved to: {PLOTS_DIR}")
#+end_src

#+RESULTS:
:results:
#+begin_exampleGenerating publication-ready images for 20 benchmarks...
Success! All images saved to: /home/han4n/cva6_experiments/results/individual_benchmark_profiles
#+end_example
:end:
** Speedup Plots
*** IPC
#+begin_src jupyter-python :results output drawer :exports results
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import os
import re
import warnings

# --- 1. Global Setup ---
RESULTS_DIR = "/home/han4n/cva6_experiments/results"
PLOTS_DIR = os.path.join(RESULTS_DIR, "speedup_plots")
os.makedirs(PLOTS_DIR, exist_ok=True)

# LaTeX & Style
plt.rc('text', usetex=True)
plt.rc('font', family='serif')
plt.rcParams['figure.dpi'] = 300
warnings.filterwarnings("ignore")

# --- 2. Helper Functions ---
def prettify_config(conf):
    """Translates config names to clean labels."""
    if conf == "Ref": return "Baseline"
    m = re.search(r'IC/DC (\d+)k', str(conf), re.IGNORECASE)
    if m: return f"{m.group(1)}KB"
    m = re.search(r'^(\d+)w$', str(conf), re.IGNORECASE)
    if m: return f"{m.group(1)}-Way"
    m = re.search(r'BTB(\d+)', str(conf), re.IGNORECASE)
    if m: return f"BTB-{m.group(1)}"
    m = re.search(r'BHT(\d+)', str(conf), re.IGNORECASE)
    if m: return f"BHT-{m.group(1)}"
    return conf

def get_sort_value(config_str):
    m = re.search(r'(\d+)', str(config_str))
    if m: return int(m.group(1))
    return 0

# --- 3. Load & Process Data ---
sweeps = [
    {"name": "Cache Size Sweep",    "file": "cache_sweep_benchmark_results.csv",     "palette": "Blues_d"},
    {"name": "Associativity Sweep", "file": "associativity_sweep_benchmark_results.csv", "palette": "Greens_d"},
    {"name": "BTB Size Sweep",      "file": "btb_sweep_benchmark_results.csv",       "palette": "Oranges_d"},
    {"name": "BHT Size Sweep",      "file": "bht_sweep_benchmark_results.csv",       "palette": "Purples_d"},
]

baseline_df = pd.read_csv(os.path.join(RESULTS_DIR, "baseline_results.csv"))
base_clean = baseline_df[['suite', 'name', 'score', 'ipc']].rename(
    columns={'score': 'base_score', 'ipc': 'base_ipc'}
)

print("Generating Zoomed Combined Speedup Plots...")

for sweep in sweeps:
    file_path = os.path.join(RESULTS_DIR, sweep["file"])
    if not os.path.exists(file_path):
        continue

    df = pd.read_csv(file_path)
    df_merged = pd.merge(df, base_clean, on=['suite', 'name'], how='inner')

    # Calculate Speedups
    df_merged['Performance Speedup'] = df_merged['score'] / df_merged['base_score']
    df_merged['IPC Speedup'] = df_merged['ipc'] / df_merged['base_ipc']

    df_merged['Config Label'] = df_merged['config'].apply(prettify_config)
    df_merged['sort_val'] = df_merged['config'].apply(get_sort_value)
    df_merged = df_merged.sort_values(by=['sort_val'])

    # --- PLOTTING ---
    for suite in df_merged['suite'].unique():
        subset = df_merged[df_merged['suite'] == suite]
        if subset.empty: continue

        plt.figure(figsize=(14, 7))
        sns.set_theme(style="whitegrid")

        # 1. BARS = Performance Speedup
        bar_plot = sns.barplot(
            data=subset,
            x="name",
            y="Performance Speedup",
            hue="Config Label",
            palette=sweep["palette"],
            edgecolor="black",
            linewidth=0.5,
            alpha=0.8
        )

        # 2. MARKERS = IPC Speedup
        sns.stripplot(
            data=subset,
            x="name",
            y="IPC Speedup",
            hue="Config Label",
            palette=['black'] * len(subset['Config Label'].unique()),
            dodge=True,
            marker='D',
            size=5,
            jitter=False,
            legend=False
        )

        # Reference Line
        plt.axhline(1.0, color='red', linestyle='--', linewidth=1.5, zorder=0)

        # --- DYNAMIC Y-AXIS ZOOM ---
        # Gather all Y-values (Bars + Dots) to find the active range
        all_y = pd.concat([subset['Performance Speedup'], subset['IPC Speedup']])
        y_min = all_y.min()
        y_max = all_y.max()

        # Calculate spread and apply padding
        spread = y_max - y_min
        if spread == 0: spread = 0.05
        padding = spread * 0.20 # 20% breathing room

        # Set limits
        plt.ylim(y_min - padding, y_max + padding)

        # Labels & Layout
        plt.title(f"{sweep['name']} ({suite}): Performance vs. Efficiency", fontsize=16, pad=15)
        plt.ylabel(r"Speedup Factor (Baseline = 1.0)", fontsize=12)
        plt.xlabel("Hardware Configuration", fontsize=10, style='italic', color='#444444')

        plt.xticks(rotation=70, ha='right', rotation_mode='anchor', fontsize=10)

        # Custom Legend
        handles, labels = bar_plot.get_legend_handles_labels()
        from matplotlib.lines import Line2D
        diamond_proxy = Line2D([0], [0], color='w', marker='D', markerfacecolor='black', markersize=6, label='IPC Speedup (Efficiency)')
        handles.append(diamond_proxy)
        labels.append("IPC Speedup (Efficiency)")

        plt.legend(
            handles, labels,
            title="Configuration",
            bbox_to_anchor=(1.01, 1),
            loc='upper left'
        )

        plt.tight_layout()

        filename = f"{sweep['name'].replace(' ', '_')}_{suite}.png".lower()
        plt.savefig(os.path.join(PLOTS_DIR, filename), bbox_inches='tight')
        plt.close()

print(f"Done! plots saved to: {PLOTS_DIR}")
#+end_src

#+RESULTS:
:results:
#+begin_exampleGenerating Zoomed Combined Speedup Plots...
Done! plots saved to: /home/han4n/cva6_experiments/results/speedup_plots
#+end_example
:end:
*** Counter Cycles
#+begin_src jupyter-python :results output drawer :exports results
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import os
import re
import warnings

# --- 1. Setup ---
RESULTS_DIR = "/home/han4n/cva6_experiments/results"
PLOTS_DIR = os.path.join(RESULTS_DIR, "speedup_plot_cycles")
os.makedirs(PLOTS_DIR, exist_ok=True)

# LaTeX & Style
plt.rc('text', usetex=True)
plt.rc('font', family='serif')
plt.rcParams['figure.dpi'] = 300
warnings.filterwarnings("ignore")

# --- 2. Helper Functions ---
def prettify_config(conf):
    if conf == "Ref": return "Baseline"
    m = re.search(r'IC/DC (\d+)k', str(conf), re.IGNORECASE)
    if m: return f"{m.group(1)}KB"
    m = re.search(r'^(\d+)w$', str(conf), re.IGNORECASE)
    if m: return f"{m.group(1)}-Way"
    m = re.search(r'BTB(\d+)', str(conf), re.IGNORECASE)
    if m: return f"BTB-{m.group(1)}"
    m = re.search(r'BHT(\d+)', str(conf), re.IGNORECASE)
    if m: return f"BHT-{m.group(1)}"
    return conf

def get_sort_value(config_str):
    m = re.search(r'(\d+)', str(config_str))
    if m: return int(m.group(1))
    return 0

# --- 3. BLUE-START RAINBOW PALETTE ---
# Blue -> Purple -> Crimson -> Red -> Orange -> Gold -> Green -> Cyan
# This follows the spectral cycle but shifts the starting point to Blue.
RAINBOW_COLORS = [
    "#f38ba8", # Blue
    "#fab387", # Purple
    "#a6e3a1", # Crimson (Bridge Purple->Red)
    "#74c7ec", # Red
    "#fab387", # Orange
    "#FFD700", # Gold
    "#008000", # Green
    "#00CED1", # Dark Turquoise (Cyan)
]

def get_rainbow_palette(n_colors):
    if n_colors > len(RAINBOW_COLORS):
        return RAINBOW_COLORS * (n_colors // len(RAINBOW_COLORS) + 1)
    return RAINBOW_COLORS[:n_colors]

# --- 4. Configuration ---
sweeps = [
    {"name": "Cache Size",    "file": "cache_sweep_benchmark_results.csv"},
    {"name": "Associativity", "file": "associativity_sweep_benchmark_results.csv"},
    {"name": "BTB Size",      "file": "btb_sweep_benchmark_results.csv"},
    {"name": "BHT Size",      "file": "bht_sweep_benchmark_results.csv"},
]

# Load Baseline
baseline_df = pd.read_csv(os.path.join(RESULTS_DIR, "baseline_results.csv"))
base_clean = baseline_df[['suite', 'name', 'score', 'cycles']].rename(
    columns={'score': 'base_score', 'cycles': 'base_cycles'}
)

print("Generating Blue-Start Rainbow Plots...")

for sweep in sweeps:
    file_path = os.path.join(RESULTS_DIR, sweep["file"])
    if not os.path.exists(file_path):
        continue

    df = pd.read_csv(file_path)
    df_merged = pd.merge(df, base_clean, on=['suite', 'name'], how='inner')

    # Calculate Metrics
    df_merged['Performance Speedup'] = df_merged['score'] / df_merged['base_score']
    df_merged['Cycle Speedup'] = df_merged['base_cycles'] / df_merged['cycles']

    df_merged['Config Label'] = df_merged['config'].apply(prettify_config)
    df_merged['sort_val'] = df_merged['config'].apply(get_sort_value)
    df_merged = df_merged.sort_values(by=['sort_val'])

    # --- PLOTTING ---
    for suite in df_merged['suite'].unique():
        subset = df_merged[df_merged['suite'] == suite]
        if subset.empty: continue

        n_configs = len(subset['Config Label'].unique())
        current_palette = get_rainbow_palette(n_configs)
        n_benchmarks = len(subset['name'].unique())

        fig_width = max(12, n_benchmarks * 1.3)

        plt.figure(figsize=(fig_width, 7))
        sns.set_theme(style="whitegrid")

        # 1. BARS = Performance Speedup
        bar_plot = sns.barplot(
            data=subset,
            x="name",
            y="Performance Speedup",
            hue="Config Label",
            palette=current_palette,
            edgecolor="black",
            linewidth=0.6,
            alpha=0.9
        )

        # 2. DIAMONDS = Cycle Speedup
        sns.stripplot(
            data=subset,
            x="name",
            y="Cycle Speedup",
            hue="Config Label",
            palette=['#222222'] * n_configs,
            dodge=True,
            marker='D',
            size=5,
            jitter=False,
            legend=False
        )

        # Reference Line
        plt.axhline(1.0, color='#333333', linestyle='--', linewidth=1.5, zorder=0)

        # Zoom
        all_y = pd.concat([subset['Performance Speedup'], subset['Cycle Speedup']])
        y_min, y_max = all_y.min(), all_y.max()
        padding = (y_max - y_min) * 0.15
        if padding == 0: padding = 0.05
        plt.ylim(y_min - padding, y_max + padding)

        # Labels
        plt.title(f"{suite} Suite: Sensitivity to {sweep['name']}", fontsize=18, pad=15)
        plt.ylabel(r"Speedup (Baseline = 1.0)", fontsize=14)
        plt.xlabel("")
        plt.xticks(rotation=45, ha='right', rotation_mode='anchor', fontsize=11)

        # Legend
        handles, labels = bar_plot.get_legend_handles_labels()
        from matplotlib.lines import Line2D
        diamond_proxy = Line2D([0], [0], color='w', marker='D', markerfacecolor='#222222', markersize=6, label='Cycle Speedup (Time)')
        handles.append(diamond_proxy)
        labels.append("Cycle Speedup (Time)")

        plt.legend(
            handles, labels,
            title=f"{sweep['name']} Config",
            bbox_to_anchor=(1.01, 1),
            loc='upper left',
            frameon=True
        )

        plt.tight_layout()

        filename = f"counter_cycle_{sweep['name'].replace(' ', '_')}_{suite}.png".lower()
        plt.savefig(os.path.join(PLOTS_DIR, filename), bbox_inches='tight')
        plt.close()

print(f"Done! Blue-Start Rainbow plots saved to: {PLOTS_DIR}")
#+end_src

#+RESULTS:
:results:
#+begin_exampleGenerating Blue-Start Rainbow Plots...
Done! Blue-Start Rainbow plots saved to: /home/han4n/cva6_experiments/results/speedup_plot_cycles
#+end_example
:end:
* Utilization
#+begin_src jupyter-python :results output drawer :exports results
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import re

# -----------------------------------------------------------------------------
# 1. PLOT STYLING & CONFIGURATION
# -----------------------------------------------------------------------------
# Enable LaTeX rendering and set font
try:
    plt.rc('text', usetex=True)
    plt.rc('font', family='serif')
except:
    print("Warning: LaTeX not found. Using standard fonts.")

plt.rcParams['figure.dpi'] = 300
INPUT_CSV = "cva6_experiments_stages_summary.csv"

# Baseline Configuration
BASELINE = {
    'IC_num': 4096,  'ICw_num': 4,
    'DC_num': 4096,  'DCw_num': 4,
    'BTB_num': 16,   'BHT_num': 16,   'RAS_num': 2
}

# -----------------------------------------------------------------------------
# 2. DATA LOADING
# -----------------------------------------------------------------------------
def parse_size(val):
    if isinstance(val, str):
        val = val.lower()
        if 'k' in val: return int(float(val.replace('k', '')) * 1024)
        if 'w' in val: return int(val.replace('w', ''))
        return int(val)
    return val

try:
    df = pd.read_csv(INPUT_CSV)
    for col in ['IC', 'ICw', 'DC', 'DCw', 'BTB', 'BHT', 'RAS']:
        if col in df.columns:
            df[f'{col}_num'] = df[col].apply(parse_size)
except FileNotFoundError:
    print(f"Error: {INPUT_CSV} not found.")
    exit()

# -----------------------------------------------------------------------------
# 3. PLOTTING FUNCTION
# -----------------------------------------------------------------------------
def plot_sweep_soc(df_filtered, x_col, x_label, title, filename):
    if df_filtered.empty:
        print(f"Skipping {title} (no data)")
        return

    df_plot = df_filtered.sort_values(f'{x_col}_num')
    labels = df_plot[x_col].astype(str).tolist()

    # Data
    luts = df_plot['SoC_Total_LUT'].tolist()
    ffs = df_plot['SoC_Total_FF'].tolist()
    brams = df_plot['SoC_Total_BRAM'].tolist()
    dsps = df_plot['SoC_Total_DSP'].tolist()

    x = np.arange(len(labels))
    width = 0.2

    fig, ax = plt.subplots(figsize=(12, 7))

    # Bars
    rects1 = ax.bar(x - 1.5*width, luts, width, label='LUT', color='#4c72b0')
    rects2 = ax.bar(x - 0.5*width, ffs, width, label='FF', color='#55a868')
    rects3 = ax.bar(x + 0.5*width, brams, width, label='BRAM', color='#c44e52')
    rects4 = ax.bar(x + 1.5*width, dsps, width, label='DSP', color='#8172b2')

    # Styling
    ax.set_xlabel(x_label, fontsize=12)
    ax.set_ylabel(r'\textbf{Total Utilization (Count)}', fontsize=12)
    ax.set_title(rf'\textbf{{{title}}}', fontsize=14, pad=15)
    ax.set_xticks(x)
    ax.set_xticklabels(labels, fontsize=11)
    ax.grid(axis='y', linestyle='--', alpha=0.5, zorder=0)

    # 1. Dynamic Y-Limit: Increase by 30% to make room for the legend on top
    max_val = max(max(luts), max(ffs), max(brams), max(dsps))
    ax.set_ylim(0, max_val * 1.3)

    # 2. Legend: Placed in the empty upper-right space
    ax.legend(loc='upper right', frameon=True, fontsize=10, ncol=2)

    # 3. Bar Labels: Rotated 90 degrees to fit without crossing borders
    def add_labels(rects):
        for rect in rects:
            height = rect.get_height()
            ax.annotate(f'{int(height)}',
                        xy=(rect.get_x() + rect.get_width() / 2, height),
                        xytext=(0, 5),  # 5 points vertical offset
                        textcoords="offset points",
                        ha='center', va='bottom', rotation=90, fontsize=8)

    add_labels(rects1)
    add_labels(rects2)
    add_labels(rects3)
    add_labels(rects4)

    plt.tight_layout()
    # plt.savefig(filename, bbox_inches='tight') # Ensures nothing is cropped
    plt.show()
    print(f"Generated {filename}")
    # plt.close()

# -----------------------------------------------------------------------------
# 4. GENERATE PLOTS
# -----------------------------------------------------------------------------
# Sweep 1: Cache Size
s1 = df[(df['ICw_num'] == BASELINE['ICw_num']) & (df['DCw_num'] == BASELINE['DCw_num']) &
        (df['BTB_num'] == BASELINE['BTB_num']) & (df['BHT_num'] == BASELINE['BHT_num'])].copy()
plot_sweep_soc(s1, 'IC', r'Cache Capacity (Bytes)', 'SoC Resources vs. Cache Size', 'plot_cache.png')

# Sweep 2: Associativity
s2 = df[(df['IC_num'] == BASELINE['IC_num']) & (df['DC_num'] == BASELINE['DC_num']) &
        (df['BTB_num'] == BASELINE['BTB_num']) & (df['BHT_num'] == BASELINE['BHT_num'])].copy()
plot_sweep_soc(s2, 'ICw', r'Associativity (Ways)', 'SoC Resources vs. Associativity', 'plot_assoc.png')

# Sweep 3: BTB
s3 = df[(df['IC_num'] == BASELINE['IC_num']) & (df['ICw_num'] == BASELINE['ICw_num']) &
        (df['DC_num'] == BASELINE['DC_num']) & (df['BHT_num'] == BASELINE['BHT_num'])].copy()
plot_sweep_soc(s3, 'BTB', r'BTB Entries', 'SoC Resources vs. BTB Size', 'plot_btb.png')

# Sweep 4: BHT
s4 = df[(df['IC_num'] == BASELINE['IC_num']) & (df['ICw_num'] == BASELINE['ICw_num']) &
        (df['DC_num'] == BASELINE['DC_num']) & (df['BTB_num'] == BASELINE['BTB_num'])].copy()
plot_sweep_soc(s4, 'BHT', r'BHT Entries', 'SoC Resources vs. BHT Size', 'plot_bht.png')
#+end_src

#+RESULTS:
:results:
#+begin_example
#+end_example
[[file:./.ob-jupyter/d288a592c6564394352084e72d781ba0b34f5f14.png]]
#+begin_example
Generated plot_cache.png
#+end_example
[[file:./.ob-jupyter/24ff8c89dd35cbb9b66b3eb44570d45daf446a27.png]]
#+begin_example
Generated plot_assoc.png
#+end_example
[[file:./.ob-jupyter/b6148d544ea648cd62aa77c3b65c9c5b16ff8ac7.png]]
#+begin_example
Generated plot_btb.png
#+end_example
[[file:./.ob-jupyter/360b196048d4cf11b41b72cebcae82881b69ae2a.png]]
#+begin_example
Generated plot_bht.png
#+end_example
:end:

#+begin_src jupyter-python :results output drawer :exports results
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import numpy as np
import os

# -----------------------------------------------------------------------------
# 1. CONFIGURATION
# -----------------------------------------------------------------------------
INPUT_CSV = "cva6_experiments_stages_summary.csv"
OUTPUT_DIR = "utilization_plots"

if not os.path.exists(OUTPUT_DIR):
    os.makedirs(OUTPUT_DIR)

# Enable LaTeX styling
try:
    plt.rc('text', usetex=True)
    plt.rc('font', family='serif')
except:
    print("Warning: LaTeX not found. Using standard fonts.")

plt.rcParams['figure.dpi'] = 300

# Baseline for filtering
BASELINE = {
    'IC_num': 4096,  'ICw_num': 4,
    'DC_num': 4096,  'DCw_num': 4,
    'BTB_num': 16,   'BHT_num': 16,   'RAS_num': 2
}

# -----------------------------------------------------------------------------
# 2. HELPER FUNCTIONS
# -----------------------------------------------------------------------------
def parse_size(val):
    if isinstance(val, str):
        val = val.lower()
        if 'k' in val: return int(float(val.replace('k', '')) * 1024)
        if 'w' in val: return int(val.replace('w', ''))
        return int(val)
    return val

def get_text_color(hex_color):
    """Returns 'black' or 'white' based on background brightness."""
    rgb = mcolors.hex2color(hex_color)
    brightness = (0.299 * rgb[0] + 0.587 * rgb[1] + 0.114 * rgb[2])
    return 'black' if brightness > 0.55 else 'white'

# -----------------------------------------------------------------------------
# 3. DATA LOADING
# -----------------------------------------------------------------------------
try:
    df = pd.read_csv(INPUT_CSV)
    for col in ['IC', 'ICw', 'DC', 'DCw', 'BTB', 'BHT', 'RAS']:
        if col in df.columns:
            df[f'{col}_num'] = df[col].apply(parse_size)
except FileNotFoundError:
    print(f"Error: {INPUT_CSV} not found.")
    exit()

# -----------------------------------------------------------------------------
# 4. PLOTTING FUNCTION
# -----------------------------------------------------------------------------
def plot_split_metric(df_filtered, x_col, x_label, title_prefix, filename_prefix):
    if df_filtered.empty:
        return

    df_plot = df_filtered.sort_values(f'{x_col}_num')
    labels = df_plot[x_col].astype(str).tolist()
    x = np.arange(len(labels))
    width = 0.65

    metrics = ['LUT', 'FF', 'BRAM', 'DSP']

    stages = [
        ('S1_Fetch', 'Fetch', '#4e79a7'),        # Blue
        ('S2_Decode', 'Decode', '#f28e2b'),      # Orange
        ('S3_Issue_Net', 'Issue', '#e15759'),    # Red
        ('S4_Execute_Net', 'Execute', '#76b7b2'),# Cyan/Teal
        ('S5_Memory_Total', 'Memory', '#59a14f'),# Green
        ('S6_Commit', 'Commit', '#edc948')       # Yellow
    ]

    for metric in metrics:
        fig, ax = plt.subplots(figsize=(10, 6))

        bottoms = np.zeros(len(df_plot))
        stage_cols = [f"{s[0]}_{metric}" for s in stages]
        totals = df_plot[stage_cols].sum(axis=1).tolist()

        for s_code, s_name, s_color in stages:
            col_name = f"{s_code}_{metric}"
            values = df_plot[col_name].fillna(0).tolist()

            bars = ax.bar(x, values, width, bottom=bottoms, label=s_name,
                          color=s_color, edgecolor='white', linewidth=0.5)

            text_color = get_text_color(s_color)

            # --- ROBUST LABELING ---
            for i, rect in enumerate(bars):
                height = rect.get_height()
                total = totals[i]
                pct = (height / total * 100) if total > 0 else 0

                # Format Count
                val_str = f"{int(height)}" if height < 1000 else f"{height/1000:.1f}k"
                if metric == 'DSP': val_str = f"{int(height)}"

                label_text = ""
                font_size = 7

                # Case 1: Large Segment (> 5%) -> Show "Count (Pct%)"
                if pct > 5:
                    label_text = rf"\textbf{{{val_str}}} ({int(pct)}\%)"
                    font_size = 8

                # Case 2: Small Segment (1% - 5%) -> Show "Count" only
                elif pct > 1.0:
                    label_text = rf"\textbf{{{val_str}}}"
                    font_size = 6

                if label_text:
                    ax.annotate(label_text,
                                xy=(rect.get_x() + rect.get_width() / 2, bottoms[i] + height / 2),
                                xytext=(0, 0),
                                textcoords="offset points",
                                ha='center', va='center',
                                color=text_color, fontsize=font_size)

            bottoms += values

        # Styling
        ax.set_ylabel(rf'\textbf{{{metric} Utilization (Count)}}', fontsize=12)
        ax.set_xlabel(rf'\textbf{{{x_label}}}', fontsize=12)
        ax.set_title(rf'\textbf{{{title_prefix}: {metric} Distribution}}', fontsize=14, pad=15)

        ax.set_xticks(x)
        ax.set_xticklabels(labels, rotation=0, fontsize=11)
        ax.grid(axis='y', linestyle='--', alpha=0.4)

        if max(totals) > 0:
            ax.set_ylim(0, max(totals) * 1.1)

        ax.legend(bbox_to_anchor=(1.02, 1), loc='upper left',
                  borderaxespad=0., frameon=True, fontsize=10, title="Pipeline Stage")

        plt.tight_layout()

        save_path = os.path.join(OUTPUT_DIR, f"{filename_prefix}_{metric}.png")
        plt.savefig(save_path, bbox_inches='tight')
        print(f"Generated: {save_path}")
        plt.close()

# -----------------------------------------------------------------------------
# 5. EXECUTE SWEEPS
# -----------------------------------------------------------------------------
s1 = df[
    (df['ICw_num'] == BASELINE['ICw_num']) &
    (df['DCw_num'] == BASELINE['DCw_num']) &
    (df['BTB_num'] == BASELINE['BTB_num']) &
    (df['BHT_num'] == BASELINE['BHT_num'])
].copy()
plot_split_metric(s1, 'IC', 'Cache Capacity (Bytes)', 'Cache Size Sweep', 'sweep_cache')

s2 = df[
    (df['IC_num'] == BASELINE['IC_num']) &
    (df['DC_num'] == BASELINE['DC_num']) &
    (df['BTB_num'] == BASELINE['BTB_num']) &
    (df['BHT_num'] == BASELINE['BHT_num'])
].copy()
plot_split_metric(s2, 'ICw', 'Associativity (Ways)', 'Associativity Sweep', 'sweep_assoc')

s3 = df[
    (df['IC_num'] == BASELINE['IC_num']) &
    (df['ICw_num'] == BASELINE['ICw_num']) &
    (df['DC_num'] == BASELINE['DC_num']) &
    (df['DCw_num'] == BASELINE['DCw_num']) &
    (df['BHT_num'] == BASELINE['BHT_num'])
].copy()
plot_split_metric(s3, 'BTB', 'BTB Entries', 'BTB Size Sweep', 'sweep_btb')

s4 = df[
    (df['IC_num'] == BASELINE['IC_num']) &
    (df['ICw_num'] == BASELINE['ICw_num']) &
    (df['DC_num'] == BASELINE['DC_num']) &
    (df['DCw_num'] == BASELINE['DCw_num']) &
    (df['BTB_num'] == BASELINE['BTB_num'])
].copy()
plot_split_metric(s4, 'BHT', 'BHT Entries', 'BHT Size Sweep', 'sweep_bht')
#+end_src

#+RESULTS:
:results:
#+begin_exampleGenerated: utilization_plots/sweep_cache_LUT.png
Generated: utilization_plots/sweep_cache_FF.png
Generated: utilization_plots/sweep_cache_BRAM.png
Generated: utilization_plots/sweep_cache_DSP.png
Generated: utilization_plots/sweep_assoc_LUT.png
Generated: utilization_plots/sweep_assoc_FF.png
Generated: utilization_plots/sweep_assoc_BRAM.png
Generated: utilization_plots/sweep_assoc_DSP.png
Generated: utilization_plots/sweep_btb_LUT.png
Generated: utilization_plots/sweep_btb_FF.png
Generated: utilization_plots/sweep_btb_BRAM.png
Generated: utilization_plots/sweep_btb_DSP.png
Generated: utilization_plots/sweep_bht_LUT.png
Generated: utilization_plots/sweep_bht_FF.png
Generated: utilization_plots/sweep_bht_BRAM.png
Generated: utilization_plots/sweep_bht_DSP.png
#+end_example
:end:
